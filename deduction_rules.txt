Deduction:

1. Deduce flags and metavars from text.
dfam.deduce_flags_and_metavars,

2. Deduce the names of options from flags
don.deduce_option_names,

3. Deduce help option and final option
dso.deduce_special_options,

4. Deduce member names.
dmn.deduce_member_names,

5. Deduce separator counts from separator and metavar.
ds.deduce_separator_counts,

6. Make members.
mm.make_members,

8. Deduce indices (for the obscure situation where arguments are defined out of order)
di.deduce_indices,

9. Deduce values. "true" is the only value that can be deduced.
dv.deduce_values,

10. Deduce operations.
do.deduce_operations,

11. Deduce member count.
dmc.deduce_member_count,

12. Deduce value types
dvt.deduce_value_types,

13. Deduce member types.
dmt.deduce_member_types,

14. Deduce valid values.
dvv.deduce_valid_values,


Argument properties
-------------------
// arguments
//     * from metavar

// callback
//     * show_help if flags contains -h --help or /?

// count
//    * 0..1 if flags and operation is assign
//    * 0.. if flags and operation is append or extend
//    * based on arguments if not flags

// flags
//     * from text

// index
//     * from order in the file, but explicit indexes first

[inline]

// member_name
//    * from longest name in flags
//    * from argument

metavar
//     * from text
    * [WARNING] if operation is assign, append, extend, type isn't bool and value is None

// operation
//    * assign if max-count is 1
//    * append if max-count is greater than 1

post_operation
//     * abort if callback is show_help
    * final if flag is --

// separator
//     * deduce from argument if detect_separators is True

// separator_count
    // * deduce from argument and separator

// text
//    * raw_text

// value
//     * "true" if argument is None
//    * "true" if type is "bool"

[values]

[raw_text]


Member properties
-----------------
default
    * just {}

[member_inline]

[member_callback]

member_type
    * from default
    * from count (list if count is/can be greater than one) + value_type
    * from operation (list if append or extend) + value_type

value_type
    * from value
    * from valid_values
    * from separator_count (list or tuple if it's greater than zero)


text: from the displayed text unless given
flags: from text
meta_variable: from text
separator: meta_variable
separator_count: meta_variable and separator
count: from flags or text
index: from position in file
member_name: argument_type, longest name among flags or meta_variable
value: argument_type, type
argument_type: flags, count

action
callback


type: default, value, values, meta_variable
default: type
values: type


member_action
member_callback


Argument properties
-------------------
action
argument_type
callback
count
flags
index
member_name
meta_variable
separator
separator_count
text
value

Member properties
-----------------
default
member_action
member_callback
values
value_type
container_type